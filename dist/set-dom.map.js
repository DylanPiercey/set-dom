{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/index.js",
    "src/parse-html.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict'\n\nsetDOM.KEY = 'data-key'\nsetDOM.IGNORE = 'data-ignore'\nsetDOM.CHECKSUM = 'data-checksum'\nvar parseHTML = require(2)\nvar KEY_PREFIX = '_set-dom-'\nvar NODE_MOUNTED = KEY_PREFIX + 'mounted'\nvar ELEMENT_TYPE = 1\nvar DOCUMENT_TYPE = 9\nvar DOCUMENT_FRAGMENT_TYPE = 11\n\n// Expose api.\nmodule.exports = setDOM\n\n/**\n * @description\n * Updates existing dom to match a new dom.\n *\n * @param {Node} oldNode - The html entity to update.\n * @param {String|Node} newNode - The updated html(entity).\n */\nfunction setDOM (oldNode, newNode) {\n  // Ensure a realish dom node is provided.\n  assert(oldNode && oldNode.nodeType, 'You must provide a valid node to update.')\n\n  // Alias document element with document.\n  if (oldNode.nodeType === DOCUMENT_TYPE) oldNode = oldNode.documentElement\n\n  // Document Fragments don't have attributes, so no need to look at checksums, ignored, attributes, or node replacement.\n  if (newNode.nodeType === DOCUMENT_FRAGMENT_TYPE) {\n    // Simply update all children (and subchildren).\n    setChildNodes(oldNode, newNode)\n  } else {\n    // Otherwise we diff the entire old node.\n    setNode(oldNode, typeof newNode === 'string'\n      // If a string was provided we will parse it as dom.\n      ? parseHTML(newNode, oldNode.nodeName)\n      : newNode\n    )\n  }\n\n  // Trigger mount events on initial set.\n  if (!oldNode[NODE_MOUNTED]) {\n    oldNode[NODE_MOUNTED] = true\n    mount(oldNode)\n  }\n}\n\n/**\n * @private\n * @description\n * Updates a specific htmlNode and does whatever it takes to convert it to another one.\n *\n * @param {Node} oldNode - The previous HTMLNode.\n * @param {Node} newNode - The updated HTMLNode.\n */\nfunction setNode (oldNode, newNode) {\n  if (oldNode.nodeType === newNode.nodeType) {\n    // Handle regular element node updates.\n    if (oldNode.nodeType === ELEMENT_TYPE) {\n      // Checks if nodes are equal before diffing.\n      if (isEqualNode(oldNode, newNode)) return\n\n      // Update all children (and subchildren).\n      setChildNodes(oldNode, newNode)\n\n      // Update the elements attributes / tagName.\n      if (oldNode.nodeName === newNode.nodeName) {\n        // If we have the same nodename then we can directly update the attributes.\n        setAttributes(oldNode.attributes, newNode.attributes)\n      } else {\n        // Otherwise clone the new node to use as the existing node.\n        var newPrev = newNode.cloneNode()\n        // Copy over all existing children from the original node.\n        while (oldNode.firstChild) newPrev.appendChild(oldNode.firstChild)\n        // Replace the original node with the new one with the right tag.\n        oldNode.parentNode.replaceChild(newPrev, oldNode)\n      }\n    } else {\n      // Handle other types of node updates (text/comments/etc).\n      // If both are the same type of node we can update directly.\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue\n      }\n    }\n  } else {\n    // we have to replace the node.\n    oldNode.parentNode.replaceChild(newNode, dismount(oldNode))\n    mount(newNode)\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will update one list of attributes to match another.\n *\n * @param {NamedNodeMap} oldAttributes - The previous attributes.\n * @param {NamedNodeMap} newAttributes - The updated attributes.\n */\nfunction setAttributes (oldAttributes, newAttributes) {\n  var i, a, b, ns, name\n\n  // Remove old attributes.\n  for (i = oldAttributes.length; i--;) {\n    a = oldAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = newAttributes.getNamedItemNS(ns, name)\n    if (!b) oldAttributes.removeNamedItemNS(ns, name)\n  }\n\n  // Set new attributes.\n  for (i = newAttributes.length; i--;) {\n    a = newAttributes[i]\n    ns = a.namespaceURI\n    name = a.localName\n    b = oldAttributes.getNamedItemNS(ns, name)\n    if (!b) {\n      // Add a new attribute.\n      newAttributes.removeNamedItemNS(ns, name)\n      oldAttributes.setNamedItemNS(a)\n    } else if (b.value !== a.value) {\n      // Update existing attribute.\n      b.value = a.value\n    }\n  }\n}\n\n/**\n * @private\n * @description\n * Utility that will nodes childern to match another nodes children.\n *\n * @param {Node} oldParent - The existing parent node.\n * @param {Node} newParent - The new parent node.\n */\nfunction setChildNodes (oldParent, newParent) {\n  var checkOld, oldKey, checkNew, newKey, foundNode, keyedNodes\n  var oldNode = oldParent.firstChild\n  var newNode = newParent.firstChild\n  var extra = 0\n\n  // Extract keyed nodes from previous children and keep track of total count.\n  while (oldNode) {\n    extra++\n    checkOld = oldNode\n    oldKey = getKey(checkOld)\n    oldNode = oldNode.nextSibling\n\n    if (oldKey) {\n      if (!keyedNodes) keyedNodes = {}\n      keyedNodes[oldKey] = checkOld\n    }\n  }\n\n  // Loop over new nodes and perform updates.\n  oldNode = oldParent.firstChild\n  while (newNode) {\n    extra--\n    checkNew = newNode\n    newNode = newNode.nextSibling\n\n    if (keyedNodes && (newKey = getKey(checkNew)) && (foundNode = keyedNodes[newKey])) {\n      delete keyedNodes[newKey]\n      // If we have a key and it existed before we move the previous node to the new position if needed and diff it.\n      if (foundNode !== oldNode) {\n        oldParent.insertBefore(foundNode, oldNode)\n      } else {\n        oldNode = oldNode.nextSibling\n      }\n\n      setNode(foundNode, checkNew)\n    } else if (oldNode) {\n      checkOld = oldNode\n      oldNode = oldNode.nextSibling\n      if (getKey(checkOld)) {\n        // If the old child had a key we skip over it until the end.\n        oldParent.insertBefore(checkNew, checkOld)\n        mount(checkNew)\n      } else {\n        // Otherwise we diff the two non-keyed nodes.\n        setNode(checkOld, checkNew)\n      }\n    } else {\n      // Finally if there was no old node we add the new node.\n      oldParent.appendChild(checkNew)\n      mount(checkNew)\n    }\n  }\n\n  // Remove old keyed nodes.\n  for (oldKey in keyedNodes) {\n    extra--\n    oldParent.removeChild(dismount(keyedNodes[oldKey]))\n  }\n\n  // If we have any remaining unkeyed nodes remove them from the end.\n  while (--extra >= 0) {\n    oldParent.removeChild(dismount(oldParent.lastChild))\n  }\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a key out of an element.\n * Uses 'data-key' if possible and falls back to 'id'.\n *\n * @param {Node} node - The node to get the key for.\n * @return {string|void}\n */\nfunction getKey (node) {\n  if (node.nodeType !== ELEMENT_TYPE) return\n  var key = node.getAttribute(setDOM.KEY) || node.id\n  if (key) return KEY_PREFIX + key\n}\n\n/**\n * Checks if nodes are equal using the following by checking if\n * they are both ignored, have the same checksum, or have the\n * same contents.\n *\n * @param {Node} a - One of the nodes to compare.\n * @param {Node} b - Another node to compare.\n */\nfunction isEqualNode (a, b) {\n  return (\n    // Check if both nodes are ignored.\n    (isIgnored(a) && isIgnored(b)) ||\n    // Check if both nodes have the same checksum.\n    (getCheckSum(a) === getCheckSum(b)) ||\n    // Fall back to native isEqualNode check.\n    a.isEqualNode(b)\n  )\n}\n\n/**\n * @private\n * @description\n * Utility to try to pull a checksum attribute from an element.\n * Uses 'data-checksum' or user specified checksum property.\n *\n * @param {Node} node - The node to get the checksum for.\n * @return {string|NaN}\n */\nfunction getCheckSum (node) {\n  return node.getAttribute(setDOM.CHECKSUM) || NaN\n}\n\n/**\n * @private\n * @description\n * Utility to try to check if an element should be ignored by the algorithm.\n * Uses 'data-ignore' or user specified ignore property.\n *\n * @param {Node} node - The node to check if it should be ignored.\n * @return {boolean}\n */\nfunction isIgnored (node) {\n  return node.getAttribute(setDOM.IGNORE) != null\n}\n\n/**\n * Dispatches a mount event for the given node and children.\n *\n * @param {Node} node - the node to mount.\n * @return {node}\n */\nfunction mount (node) {\n  return dispatch(node, 'mount')\n}\n\n/**\n * Dispatches a dismount event for the given node and children.\n *\n * @param {Node} node - the node to dismount.\n * @return {node}\n */\nfunction dismount (node) {\n  return dispatch(node, 'dismount')\n}\n\n/**\n * Recursively trigger an event for a node and it's children.\n * Only emits events for keyed nodes.\n *\n * @param {Node} node - the initial node.\n * @return {Node}\n */\nfunction dispatch (node, type) {\n  // Trigger event for this element if it has a key.\n  if (getKey(node)) {\n    var ev = document.createEvent('Event')\n    var prop = { value: node }\n    ev.initEvent(type, false, false)\n    Object.defineProperty(ev, 'target', prop)\n    Object.defineProperty(ev, 'srcElement', prop)\n    node.dispatchEvent(ev)\n  }\n\n  // Dispatch to all children.\n  var child = node.firstChild\n  while (child) child = dispatch(child, type).nextSibling\n  return node\n}\n\n/**\n * @private\n * @description\n * Confirm that a value is truthy, throws an error message otherwise.\n *\n * @param {*} val - the val to test.\n * @param {string} msg - the error message on failure.\n * @throws {Error}\n */\nfunction assert (val, msg) {\n  if (!val) throw new Error('set-dom: ' + msg)\n}\n",
    "'use strict'\nvar parser = window.DOMParser && new window.DOMParser()\nvar documentRootName = 'HTML'\nvar supportsHTMLType = false\nvar supportsInnerHTML = false\nvar htmlType = 'text/html'\nvar xhtmlType = 'application/xhtml+xml'\nvar testClass = 'A'\nvar testCode = '<wbr class=\"' + testClass + '\"/>'\n\ntry {\n  // Check if browser supports text/html DOMParser\n  var parsed = parser.parseFromString(testCode, htmlType).body.firstChild\n  // Some browsers (iOS 9 and Safari 9) lowercase classes for parsed elements\n  // but only when appending to DOM, so use innerHTML instead\n  var d = document.createElement('div')\n  d.appendChild(parsed)\n  if (d.firstChild.classList[0] !== testClass) throw new Error()\n  supportsHTMLType = true\n} catch (e) {}\n\nvar mockDoc = document.implementation.createHTMLDocument('')\nvar mockHTML = mockDoc.documentElement\nvar mockBody = mockDoc.body\ntry {\n  // Check if browser supports documentElement.innerHTML\n  mockHTML.innerHTML += ''\n  supportsInnerHTML = true\n} catch (e) {\n  // Check if browser supports xhtml parsing.\n  parser.parseFromString(testCode, xhtmlType)\n  var bodyReg = /(<body[^>]*>)([\\s\\S]*)<\\/body>/\n}\n\nfunction DOMParserParse (markup, rootName) {\n  var doc = parser.parseFromString(markup, htmlType)\n  // Patch for iOS UIWebView not always returning doc.body synchronously\n  if (!doc.body) { return fallbackParse(markup, rootName) }\n\n  return rootName === documentRootName\n    ? doc.documentElement\n    : doc.body.firstChild\n}\n\nfunction fallbackParse (markup, rootName) {\n  // Fallback to innerHTML for other older browsers.\n  if (rootName === documentRootName) {\n    if (supportsInnerHTML) {\n      mockHTML.innerHTML = markup\n      return mockHTML\n    } else {\n      // IE9 does not support innerhtml at root level.\n      // We get around this by parsing everything except the body as xhtml.\n      var bodyMatch = markup.match(bodyReg)\n      if (bodyMatch) {\n        var bodyContent = bodyMatch[2]\n        var startBody = bodyMatch.index + bodyMatch[1].length\n        var endBody = startBody + bodyContent.length\n        markup = markup.slice(0, startBody) + markup.slice(endBody)\n        mockBody.innerHTML = bodyContent\n      }\n\n      var doc = parser.parseFromString(markup, xhtmlType)\n      var body = doc.body\n      while (mockBody.firstChild) body.appendChild(mockBody.firstChild)\n      return doc.documentElement\n    }\n  } else {\n    mockBody.innerHTML = markup\n    return mockBody.firstChild\n  }\n}\n\n/**\n * Returns the results of a DOMParser as an HTMLElement.\n * (Shims for older browsers).\n */\nmodule.exports = supportsHTMLType\n  ? DOMParserParse\n  : fallbackParse\n"
  ]
}